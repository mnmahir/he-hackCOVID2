from tkinter import *import timeimport cv2import numpyfrom PIL import Image, ImageTk#import imutils#cap = cv2.VideoCapture(0)#faceCascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")class App:        def __init__(self,video_source=0):        self.window= Tk()        self.numofpeople=Label(self.window, text="No. of People = ",font=15, anchor="w").grid(column=0, row=1,sticky="W")        self.numofviolations=Label(self.window, text="No. of Violations = ",font=15, anchor="w").grid(column=0, row=2,sticky="W")        self.numofmask=Label(self.window, text="No. of People wearing masks = ",font=15, anchor="w").grid(column=0, row=3,sticky="W")        self.numofnomask=Label(self.window, text="No. of People not wearing masks = ",font=15, anchor="w").grid(column=0, row=4,sticky="W")        self.video_source = video_source        self.video = camera(self.video_source)                self.canvas=Canvas(self.window, width = 1000, height = 700, bg='red')        self.canvas.grid(column=0, row=5)                        self.update()        self.window.mainloop()                            def update(self):                   isTrue, frame = self.video.getFrame()                  if isTrue:             self.photo = ImageTk.PhotoImage(image = Image.fromarray(frame))              #self.canvas = self.photo.subsample(2,2)             self.canvas.create_image(0,0, image = self.photo, anchor = NW)                                                  self.window.after(5, self.update) #call update method at every 15 secondsclass camera:    #Check if webcam is available or not        def __init__(self,video_source=0):        self.cap = cv2.VideoCapture(video_source)        self.faceCascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")        if not self.cap.isOpened():            #raise IOError("Webcam not available")            raise ValueError("Webcam not available",video_source)        while True:            ret, self.frame = self.cap.read()            #Mirrors the input camera footage            self.frame = cv2.flip(self.frame,1)                        self.faces = self.faceCascade.detectMultiScale(                self.frame, #Source                scaleFactor = 1.2, #This has a 20% scale factor which means that the model is thorough but works slower                minNeighbors = 5, #Affect quality of detected faces. Higher value results in less detection but higher quality. 3-6                minSize = (30, 30) #Minimum object size. (30, 30) is good for face detection            )                        print("Found {0} faces!".format(len(self.faces)))                        for (x, y, w, h) in self.faces:                cv2.rectangle(self.frame, (x, y), (x+w, y+h), (0, 255, 0), 2)                                                        self.face_detection=cv2.imshow('Camera', self.frame)                                #Press 'q' to close the camera feed            if cv2.waitKey(1) & 0xFF == ord('q'):                break                def getFrame(self):         if self.cap.isOpened():             #isTrue, frame = self.cap.read()             isTrue, frame =self.face_detection.read()             if isTrue:                 return(isTrue, cv2.cvtColor(mainframe, cv2.COLOR_BGR2RGB))                          else:                  return (isTrue, None)                                   else:             return (isTrue, None)                    # =============================================================================#     cap.release()#     cv2.destroyAllWindows()# =============================================================================App()